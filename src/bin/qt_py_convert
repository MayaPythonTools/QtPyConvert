#!/tools/bin/python2.7
import os
import sys

if sys.version_info[0] == 2 and sys.version_info[1] < 7:
    import dd.runtime.api
    dd.runtime.api.load("argparse")
import argparse

from qt_py_convert.run import process_file, process_folder


def parse():
    parser = argparse.ArgumentParser(
        "qt_py_convert"
    )

    parser.add_argument(
        "files_or_directories",
        nargs="+",
        help="Pass explicit files or a directories to run."
    )
    parser.add_argument(
        "-r", "--recursive",
        action="store_true",
        help="Recursively search for python files to convert. "
             "Only applicable when passing a directory.",
    )
    parser.add_argument(
        "-w", "--write",
        action="store_true",
        help="Overwrite the file in place.",
    )
    parser.add_argument(
        "--no-lines",
        action="store_true",
        help="Turn off printing the line numbers that things are replaced at. "
             "Ends up being much faster.",
    )
    parser.add_argument(
        "--to-method-support",
        action="store_true",
        help="Attempt to replace api1.0 style \"toString\" \"toPyObject\" etc "
             "methods that are unneeded in api2.0.",
    )
    return parser.parse_args()


def _resolve_stdin(paths):
    """
    _resolve_stdin allows us to have "-" in our files_or_directories and have
        it expand to input from stdin.
    This allows us to pipe into qt_py_convert.

    :param paths: List of strings. It wll replace any strings matching "-"
        with sys.stdin.
    :type paths: list[str...]
    :return: List that has been modified to include stdin.
    :rtype: list[str...]
    """
    _stdin = None
    _inserted = 0
    for index, path in enumerate(paths[:]):
        if path == "-":  # Insert stdin anytime we see "-"
            _index = index+_inserted  # Calculated index after insertions.
            paths.pop(_index)  # Remove the "-"
            if _stdin is None:  # If we haven't pulled from stdin yet.
                _stdin = [
                    x.strip("\n").strip("\r")  # Strip \n and \r
                    for x in list(sys.stdin)  # Iterate through stdin.
                ]
            # Generate a new list.
            # Basically if I could do an "insert" and an "expand" at once.
            paths = paths[:_index] + _stdin + paths[_index:]
            # We have inserted x - 1 because we popped.
            _inserted += len(_stdin) - 1
    return paths


def main(pathlist, recursive=True, write=False, no_lines=False, tometh_flag=False):
    # if len(pathlist) == 1:
    #     if pathlist[0] == "-":  # Support for piping on unix.
    #         pathlist = sys.stdin

    pathlist = _resolve_stdin(pathlist)

    for path in [os.path.abspath(p) for p in pathlist]:
        # print("Processing %s" % path)
        if os.path.isdir(path):
            process_folder(
                path,
                recursive=recursive,
                write=write,
                skip_lineno=no_lines,
                tometh_flag=tometh_flag
            )
        else:
            process_file(
                path,
                write=write,
                skip_lineno=no_lines,
                tometh_flag=tometh_flag
            )


if __name__ == "__main__":
    args = parse()
    main(
        args.files_or_directories,
        args.recursive,
        args.write,
        args.no_lines,
        args.to_method_support,
    )
